using Colourful;
using ComputeSharp;
using System.Diagnostics;
using System.Drawing;
using System.Text.Json;

// Version 2 idea:
// 1. Pass a randomly shuffled array of all indices to the compute shader at the start of every iteration.
//    Ideally this random array of numbers would be generated by one, or even several GPU threads.
// 2. Let the compute shader save the swap index pairs that'd improve the image. The swaps are array index 0 with index 1, index 2 with index 3, etc.
// 3. Do the saved swaps.

static public class ShuffleExtension
{
    private static Random rng = new Random();

    public static void Shuffle<T>(this IList<T> list)
    {
        int n = list.Count;
        while (n > 1)
        {
            n--;
            int k = rng.Next(n + 1);
            T value = list[k];
            list[k] = list[n];
            list[n] = value;
        }
    }
}

internal class Program
{
    const int ITERATIONS = 1000;

    // TODO: Let the user specify a kernel matrix so pixels near the kernel edges don't count equally
    const int KERNEL_RADIUS = 15;

    //const string INPUT_IMAGE_PATH = "I:/Programming/Color-Sorting/2d/gpu-swap/Color-Sorting/Color-Sorting/ultra_20000.png";
    const string INPUT_IMAGE_PATH = "I:/Programming/Color-Sorting/2d/gpu-swap/Color-Sorting/Color-Sorting/big_palette.png";
    //const string INPUT_IMAGE_PATH = "I:/Programming/Color-Sorting/2d/gpu-swap/Color-Sorting/Color-Sorting/cat.jpg";
    //const string INPUT_IMAGE_PATH = "I:/Programming/Color-Sorting/2d/gpu-swap/Color-Sorting/Color-Sorting/palette.bmp";
    //const string INPUT_IMAGE_PATH = "I:/Programming/Color-Sorting/2d/gpu-swap/Color-Sorting/Color-Sorting/10x10_palette.bmp";
    //const string INPUT_IMAGE_PATH = "I:/Programming/Color-Sorting/2d/gpu-swap/Color-Sorting/Color-Sorting/rainbow.png";
    //const string INPUT_IMAGE_PATH = "I:/Programming/Color-Sorting/2d/gpu-swap/Color-Sorting/Color-Sorting/shouldnt-swap.png";

    const string OUTPUT_IMAGES_DIRECTORY_PATH = "I:/Programming/Color-Sorting/2d/gpu-swap/Color-Sorting/Color-Sorting/output";

    const string LAB_INFO_JSON_FILE_PATH = "LabInfo.json";

    static private LabInformation labInfo;
    static private Bitmap img;
    static private Rgba32[,] pixels;

    private static void Main(string[] args)
    {
        img = new Bitmap(INPUT_IMAGE_PATH);
        var width = img.Width;
        var height = img.Height;


        labInfo = new LabInformation();
        labInfo.Init();

        // TODO: Try using Rgb everywhere instead, to save bytes.
        pixels = new Rgba32[height, width];

        Console.WriteLine("Lab normalizing pixels...");
        LabNormalizePixels();

        var rnd = new Random();

        Console.WriteLine("Allocating pixels GPU texture...");
        using var texture = GraphicsDevice.GetDefault().AllocateReadWriteTexture2D<Rgba32, float4>(pixels);

        var indicesList = Enumerable.Range(0, width * height).ToList();

        int pairCount = indicesList.Count / 2;

        var timer = new Stopwatch();
        timer.Start();

        using var indicesBuffer = GraphicsDevice.GetDefault().AllocateReadWriteBuffer(indicesList.ToArray());

        using var readTexture = GraphicsDevice.GetDefault().AllocateReadOnlyTexture2D<Rgba32, float4>(pixels);
        using var writeTexture = GraphicsDevice.GetDefault().AllocateReadWriteTexture2D<Rgba32, float4>(pixels);

        for (int i = 0; i < ITERATIONS; i++)
        {
            Console.Write("\rIteration {0}/{1}...", i + 1, ITERATIONS);

            var f = new Stopwatch();
            f.Start();

            var a = new Stopwatch();
            a.Start();
            indicesList.Shuffle();
            a.Stop();
            Console.WriteLine("\n{0} ticks shuffle", a.ElapsedTicks);

            var b = new Stopwatch();
            b.Start();
            // TODO: Try turning indicesList into indicesArray
            indicesBuffer.CopyFrom(indicesList.ToArray());
            b.Stop();
            Console.WriteLine("{0} ticks copy indicesList", b.ElapsedTicks);

            var c = new Stopwatch();
            c.Start();
            readTexture.CopyFrom(pixels);
            c.Stop();
            Console.WriteLine("{0} ticks copy from pixels", c.ElapsedTicks);

            var d = new Stopwatch();
            d.Start();
            GraphicsDevice.GetDefault().For(pairCount, new SwapComputeShader(indicesBuffer, readTexture, writeTexture, width, height, KERNEL_RADIUS));
            d.Stop();
            Console.WriteLine("{0} ticks shader", d.ElapsedTicks);

            var e = new Stopwatch();
            e.Start();
            writeTexture.CopyTo(pixels);
            e.Stop();
            Console.WriteLine("{0} ticks copy to pixels", e.ElapsedTicks);

            f.Stop();
            Console.WriteLine("{0} ticks per iteration", f.ElapsedTicks);
        }

        Console.Write("\n");

        timer.Stop();
        Console.WriteLine("Iteration time: {0:%h} hours, {0:%m} minutes, {0:%s} seconds", timer.Elapsed);

        Console.WriteLine("Lab denormalizing pixels...");

        LabDenormalizePixels();

        using var textureResult = GraphicsDevice.GetDefault().AllocateReadWriteTexture2D<Rgba32, float4>(pixels);
        Console.WriteLine("Saving result...");
        Directory.CreateDirectory(OUTPUT_IMAGES_DIRECTORY_PATH);
        var filename = String.Format("{0}_r{1}_i{2}_t{3}.png", Path.GetFileNameWithoutExtension(INPUT_IMAGE_PATH), KERNEL_RADIUS, ITERATIONS, DateTimeOffset.Now.ToUnixTimeSeconds());
        textureResult.Save(Path.Combine(OUTPUT_IMAGES_DIRECTORY_PATH, filename));
    }

    private static void LabNormalizePixels()
    {
        for (int y = 0; y < img.Height; ++y)
        {
            for (int x = 0; x < img.Width; ++x)
            {
                var pixel = img.GetPixel(x, y);

                var rgb = new RGBColor(Convert.ToDouble(pixel.R) / 255, Convert.ToDouble(pixel.G) / 255, Convert.ToDouble(pixel.B) / 255);
                var lab = labInfo.RGBToLab.Convert(rgb);

                var normalizedL = GetNormalizedLab(lab.L, labInfo.minL, labInfo.rangeL);
                var normalizedA = GetNormalizedLab(lab.a, labInfo.minA, labInfo.rangeA);
                var normalizedB = GetNormalizedLab(lab.b, labInfo.minB, labInfo.rangeB);
                pixels[y, x] = new Rgba32(normalizedL, normalizedA, normalizedB);
            }
        }
    }

    private static byte GetNormalizedLab(double x, double min, double range)
    {
        return Convert.ToByte(((x - min) / range) * 255);
    }

    private static void LabDenormalizePixels()
    {
        for (int y = 0; y < img.Height; ++y)
        {
            for (int x = 0; x < img.Width; ++x)
            {
                var pixel = pixels[y, x];

                var L = GetDenormalizedLab(pixel.R, labInfo.minL, labInfo.rangeL);
                var A = GetDenormalizedLab(pixel.G, labInfo.minA, labInfo.rangeA);
                var B = GetDenormalizedLab(pixel.B, labInfo.minB, labInfo.rangeB);
                var lab = new LabColor(L, A, B);
                var rgb = labInfo.LabToRGB.Convert(lab);

                var denormalizedR = Convert.ToByte(Math.Clamp(rgb.R * 255, 0, 255));
                var denormalizedG = Convert.ToByte(Math.Clamp(rgb.G * 255, 0, 255));
                var denormalizedB = Convert.ToByte(Math.Clamp(rgb.B * 255, 0, 255));
                pixels[y, x] = new Rgba32(denormalizedR, denormalizedG, denormalizedB);
            }
        }
    }

    private static double GetDenormalizedLab(double x, double min, double range)
    {
        return ((x / 255) * range) + min;
    }

    class LabInformation
    {
        public IColorConverter<RGBColor, LabColor> RGBToLab;
        public IColorConverter<LabColor, RGBColor> LabToRGB;

        public double minL { get; set; }
        public double minA { get; set; }
        public double minB { get; set; }

        private double maxL = double.MinValue;
        private double maxA = double.MinValue;
        private double maxB = double.MinValue;

        public double rangeL { get; set; }
        public double rangeA { get; set; }
        public double rangeB { get; set; }

        public void Init()
        {
            var rgbWorkingSpace = RGBWorkingSpaces.sRGB;
            RGBToLab = new ConverterBuilder().FromRGB(rgbWorkingSpace).ToLab(Illuminants.D50).Build();
            LabToRGB = new ConverterBuilder().FromLab(Illuminants.D50).ToRGB(rgbWorkingSpace).Build();

            if (File.Exists(LAB_INFO_JSON_FILE_PATH))
            {
                string jsonString = File.ReadAllText(LAB_INFO_JSON_FILE_PATH);

                LabInformation deserializedLabInfo = JsonSerializer.Deserialize<LabInformation>(jsonString)!;

                minL = deserializedLabInfo.minL;
                minA = deserializedLabInfo.minA;
                minB = deserializedLabInfo.minB;

                rangeL = deserializedLabInfo.rangeL;
                rangeA = deserializedLabInfo.rangeA;
                rangeB = deserializedLabInfo.rangeB;
            }
            else
            {
                Calculate();
                var options = new JsonSerializerOptions { WriteIndented = true };
                string json = JsonSerializer.Serialize(this, options);
                File.WriteAllText(LAB_INFO_JSON_FILE_PATH, json);
            }
        }

        // Source: https://stackoverflow.com/a/19099064/13279557
        private void Calculate()
        {
            minL = double.MaxValue;
            minA = double.MaxValue;
            minB = double.MaxValue;

            // TODO: Change this back to 256!!!
            for (double r = 0; r < 256; ++r)
            {
                Console.Write(String.Format("\rCalculating Lab min, max and range. The result will be saved to a file. Progress: {0}/255", r));

                for (double g = 0; g < 256; ++g)
                    for (double b = 0; b < 256; ++b)
                    {
                        var rgb = new RGBColor(r / 255, g / 255, b / 255);
                        var lab = RGBToLab.Convert(rgb);

                        minL = Math.Min(minL, lab.L);
                        minA = Math.Min(minA, lab.a);
                        minB = Math.Min(minB, lab.b);

                        maxL = Math.Max(maxL, lab.L);
                        maxA = Math.Max(maxA, lab.a);
                        maxB = Math.Max(maxB, lab.b);
                    }
            }

            Console.Write("\n");

            rangeL = maxL - minL;
            rangeA = maxA - minA;
            rangeB = maxB - minB;
        }

        public void Print()
        {
            Console.WriteLine(String.Format("L is always between [{0}, {1}], range {2}", minL, maxL, rangeL));
            Console.WriteLine(String.Format("a is always between [{0}, {1}], range {2}", minA, maxA, rangeA));
            Console.WriteLine(String.Format("b is always between [{0}, {1}], range {2}", minB, maxB, rangeB));
        }
    }
}

[AutoConstructor]
// [EmbeddedBytecode(DispatchAxis.X)] // Doesn't seem to speed the program up
public readonly partial struct SwapComputeShader : IComputeShader
{
    public readonly ReadWriteBuffer<int> indices;

    public readonly IReadOnlyNormalizedTexture2D<float4> readTexture;
    public readonly IReadWriteNormalizedTexture2D<float4> writeTexture;

    public readonly int width;
    public readonly int height;

    public readonly int KERNEL_RADIUS;

    public void Execute()
    {
        int aIndex1D = indices[ThreadIds.X * 2 + 0];
        int bIndex1D = indices[ThreadIds.X * 2 + 1];

        int2 aIndex = new int2(getX(aIndex1D), getY(aIndex1D));
        int2 bIndex = new int2(getX(bIndex1D), getY(bIndex1D));

        float4 a = readTexture[aIndex];
        float4 b = readTexture[bIndex];

        int score = getScoreDifference(aIndex, a, b) + getScoreDifference(bIndex, b, a);

        // If swapping pixels `a` and `b` would improve the image, do the swap
        if (score < 0)
        {
            writeTexture[aIndex] = b;
            writeTexture[bIndex] = a;
        }

        // TODO: Possibly faster:
        //writeTexture[aIndex] = score < 0 ? b : a;
        //writeTexture[bIndex] = score < 0 ? a : b;
    }

    private int getX(int index)
    {
        return index % width;
    }

    private int getY(int index)
    {
        return index / width;
    }

    private int getScoreDifference(int2 centerIndex, float4 oldCenterPixel, float4 newCenterPixel)
    {
        int score = 0;

        /*
        for (int dy = -KERNEL_RADIUS; dy <= KERNEL_RADIUS; dy++)
        {
            if (centerIndex.Y + dy == -1 || centerIndex.Y + dy == height)
                continue;

            for (int dx = -KERNEL_RADIUS; dx <= KERNEL_RADIUS; dx++)
            {
                if (centerIndex.X + dx == -1 || centerIndex.X + dx == width || (dx == 0 && dy == 0))
                    continue;

                int2 neighborIndex = centerIndex + new int2(dx, dy);
                float4 neighborPixel = readTexture[neighborIndex];

                score -= getColorDifference(oldCenterPixel, neighborPixel);
                score += getColorDifference(newCenterPixel, neighborPixel);
            }
        }
        */

        Top(ref score, centerIndex, oldCenterPixel, newCenterPixel);
        Bottom(ref score, centerIndex, oldCenterPixel, newCenterPixel);
        Left(ref score, centerIndex, oldCenterPixel, newCenterPixel);
        Right(ref score, centerIndex, oldCenterPixel, newCenterPixel);

        return (score);
    }

    private void Top(ref int score, int2 centerIndex, float4 oldCenterPixel, float4 newCenterPixel)
    {
        // Explanation:
        // If centerIndex.Y is 1 and KERNEL_RADIUS is 2, then centerIndex.Y - KERNEL_RADIUS is -1. max(-1, 0) is 0, so ny starts at 0
        // If centerIndex.Y is 3 and KERNEL_RADIUS is 2, then centerIndex.Y - KERNEL_RADIUS is 1. max(1, 0) is 1, so ny starts at 1
        for (int ny = Hlsl.Max(centerIndex.Y - KERNEL_RADIUS, 0); ny < centerIndex.Y; ny++)
        {
            // Explanation:
            // If centerIndex.X is 1 and KERNEL_RADIUS is 2, then centerIndex.X - KERNEL_RADIUS is -1. max(-1, 0) is 0, so nx starts at 0
            // If centerIndex.X is 1 and KERNEL_RADIUS is 2 and width is 3, then centerIndex.X + KERNEL_RADIUS + 1 is 4. min(4, 3) is 3, so nx will stay less than 3
            //
            // If centerIndex.X is 3 and KERNEL_RADIUS is 2, then centerIndex.X - KERNEL_RADIUS is 1. max(1, 0) is 1, so nx starts at 1
            // If centerIndex.X is 3 and KERNEL_RADIUS is 2 and width is 7, then centerIndex.X + KERNEL_RADIUS + 1 is 6. min(6, 7) is 6, so nx will stay less than 6
            for (int nx = Hlsl.Max(centerIndex.X - KERNEL_RADIUS, 0); nx < Hlsl.Min(centerIndex.X + KERNEL_RADIUS + 1, width); nx++)
            {
                int2 neighborIndex = new int2(nx, ny);
                float4 neighborPixel = readTexture[neighborIndex];

                score -= getColorDifference(oldCenterPixel, neighborPixel);
                score += getColorDifference(newCenterPixel, neighborPixel);
            }
        }
    }

    public void Bottom(ref int score, int2 centerIndex, float4 oldCenterPixel, float4 newCenterPixel)
    {
        // Explanation:
        // If centerIndex.Y is 1 and KERNEL_RADIUS is 1 and height is 3, then centerIndex.Y + KERNEL_RADIUS + 1 is 3. min(3, 3) is 3, so ny will stay less than 3
        // If centerIndex.Y is 1 and KERNEL_RADIUS is 1 and height is 2, then centerIndex.Y + KERNEL_RADIUS + 1 is 3. min(3, 2) is 2, so ny will stay less than 2
        for (int ny = centerIndex.Y + 1; ny < Hlsl.Min(centerIndex.Y + KERNEL_RADIUS + 1, height); ny++)
        {
            for (int nx = Hlsl.Max(centerIndex.X - KERNEL_RADIUS, 0); nx < Hlsl.Min(centerIndex.X + KERNEL_RADIUS + 1, width); nx++)
            {
                int2 neighborIndex = new int2(nx, ny);
                float4 neighborPixel = readTexture[neighborIndex];

                score -= getColorDifference(oldCenterPixel, neighborPixel);
                score += getColorDifference(newCenterPixel, neighborPixel);
            }
        }
    }

    public void Left(ref int score, int2 centerIndex, float4 oldCenterPixel, float4 newCenterPixel)
    {
        for (int nx = Hlsl.Max(centerIndex.X - KERNEL_RADIUS, 0); nx < centerIndex.X; nx++)
        {
            int2 neighborIndex = new int2(nx, centerIndex.Y);
            float4 neighborPixel = readTexture[neighborIndex];

            score -= getColorDifference(oldCenterPixel, neighborPixel);
            score += getColorDifference(newCenterPixel, neighborPixel);
        }
    }

    public void Right(ref int score, int2 centerIndex, float4 oldCenterPixel, float4 newCenterPixel)
    {
        // Explanation:
        // If centerIndex.X is 1 and KERNEL_RADIUS is 2 and width is 3, then centerIndex.X + 1 is 2. min(2, 3 - 1) is 2, so nx starts at 2
        // If centerIndex.X is 2 and KERNEL_RADIUS is 2 and width is 3, then centerIndex.X + 1 is 3. min(3, 3 - 1) is 2, so nx starts at 2
        for (int nx = Hlsl.Min(centerIndex.X + 1, width - 1); nx < Hlsl.Min(centerIndex.X + KERNEL_RADIUS + 1, width); nx++)
        {
            int2 neighborIndex = new int2(nx, centerIndex.Y);
            float4 neighborPixel = readTexture[neighborIndex];

            score -= getColorDifference(oldCenterPixel, neighborPixel);
            score += getColorDifference(newCenterPixel, neighborPixel);
        }
    }

    private int getColorDifference(float4 c1, float4 c2)
    {
        var l = (c1.R * 255) - (c2.R * 255);
        var a = (c1.G * 255) - (c2.G * 255);
        var b = (c1.B * 255) - (c2.B * 255);

        return (int)(l * l + a * a + b * b);
    }
}